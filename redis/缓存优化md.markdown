[TOC]

# 缓存穿透
> 5000个请求，4000个黑客恶意攻击，只有1000个可以被有效缓存

![img](assets/d61ba2a3-5030-4326-aa12-f25a95c540b5.png)


**解决方案**
1. 鉴权
2. 缓存空值(过期删除)
3. 布隆过滤器( `大概率存在，允许有漏网之鱼`)

<br/>

# 缓存击穿
> 高并发的情况下，某个热点key在失效的瞬间，瞬间击穿了缓存（就像是在一道屏障上击穿了一个洞）。

**解决方案:**
1、加互斥锁。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。
2、热点数据不过期。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。


<br/>



# 缓存雪崩
> 大量的热点 key 设置了相同的过期时间，导在缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩，甚至导致数据库被打挂。
缓存雪崩其实有点像“升级版的缓存击穿”，缓存击穿是一个热点 key，缓存雪崩是一组热点 key。

**解决方案:**
1、过期时间打散。
2、热点数据不过期。该方式和缓存击穿一样，也是要着重考虑刷新的时间间隔和数据异常如何处理的情况。
3、加互斥锁。该方式和缓存击穿一样，按 key 维度加锁，对于同一个 key，只允许一个线程去计算，其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存即可。





---

# 哨兵模式： 
http://www.cnblogs.com/kerwinC/p/6069864.html
https://blog.csdn.net/heyewu4107/article/details/71009712
https://blog.csdn.net/u010359884/article/details/50310387
https://www.cnblogs.com/VergiLyn/p/7968094.html
https://www.cnblogs.com/onions/p/5685674.html
https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug

